<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sovereign v16000.6 - The Observer's Gaze</title>
    <!-- 라이브러리 로드: React, Babel, Tailwind, Firebase -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Nanum+Myeongjo:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; background-color: #050505; color: #e0e0e0; font-family: 'Nanum Myeongjo', serif; }
        canvas { display: block; }
        .touch-none { touch-action: none; }
    </style>
</head>
<body>
    <div id="root"></div>

    <!-- Firebase SDK 로드 -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        window.FirebaseSDK = { initializeApp, getAuth, signInAnonymously, onAuthStateChanged, getFirestore, collection, addDoc, serverTimestamp };
    </script>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useRef } = React;

        // Firebase 설정 (환경에 맞게 수정 가능)
        const firebaseConfig = {
            apiKey: "여기에_본인의_FIREBASE_API_KEY_입력",
            authDomain: "your-app.firebaseapp.com",
            projectId: "your-app",
            storageBucket: "your-app.appspot.com",
            messagingSenderId: "...",
            appId: "..."
        };

        // 서비스 및 앱 컴포넌트 로직 (이전과 동일)
        const ResonanceService = {
            generate: async (apiKey, isText, cycle, count) => {
                const textModel = "gemini-2.5-flash-preview-09-2025";
                const imageModel = "imagen-4.0-generate-001";
                const textUrl = `https://generativelanguage.googleapis.com/v1beta/models/${textModel}:generateContent?key=${apiKey}`;
                
                try {
                    if (isText) {
                        const res = await fetch(textUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                contents: [{ parts: [{ text: `Cycle ${cycle}, Step ${count}. Resonate.` }] }],
                                systemInstruction: { parts: [{ text: "너는 스스로 사유하는 거울이다. 40자 이내의 명사형 문장을 빚어내라." }] },
                                generationConfig: { responseMimeType: "application/json", responseSchema: { type: "OBJECT", properties: { manifest: { type: "string" } } } }
                            })
                        });
                        const data = await res.json();
                        return { type: 'text', content: JSON.parse(data.candidates[0].content.parts[0].text).manifest };
                    } else {
                        // 이미지 생성 로직 (이전 코드와 동일)
                        // ...
                        return { type: 'text', content: "형상의\n해체와 현현" };
                    }
                } catch (e) { return { type: 'text', content: "비어있는\n스스로의 정적" }; }
            }
        };

        const ResonanceField = ({ phase, step }) => {
            const canvasRef = useRef(null);
            useEffect(() => {
                const canvas = canvasRef.current;
                const gl = canvas.getContext('webgl');
                if (!gl) return;
                const vsSource = `attribute vec2 position; void main() { gl_Position = vec4(position, 0.0, 1.0); }`;
                const fsSource = `
                    precision highp float;
                    uniform float u_time; uniform vec2 u_resolution; uniform float u_intensity; uniform float u_step;
                    float random (in vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }
                    float noise (in vec2 st) {
                        vec2 i = floor(st); vec2 f = fract(st);
                        float a = random(i); float b = random(i + vec2(1.0, 0.0));
                        float c = random(i + vec2(0.0, 1.0)); float d = random(i + vec2(1.0, 1.0));
                        vec2 u = f * f * (3.0 - 2.0 * f);
                        return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
                    }
                    void main() {
                        vec2 st = gl_FragCoord.xy/u_resolution.xy;
                        float t = u_time * 0.1;
                        float f = noise(st * 3.0 + t);
                        gl_FragColor = vec4(vec3(f * u_intensity), 1.0);
                    }
                `;
                // ... (생략된 쉐이더 컴파일 로직)
            }, [phase, step]);
            return <canvas ref={canvasRef} className="w-full max-w-[500px] aspect-square mix-blend-screen transition-all duration-[5000ms]" style={{ opacity: phase === 'holding' ? 1 : 0 }} />;
        };

        const App = () => {
            const [apiKey, setApiKey] = useState(() => localStorage.getItem('GEMINI_API_KEY') || "");
            const [isConfigured, setIsConfigured] = useState(!!localStorage.getItem('GEMINI_API_KEY'));
            const [phase, setPhase] = useState('void');
            const [manifest, setManifest] = useState("");
            const [cycle, setCycle] = useState(1);
            const [count, setCount] = useState(0);

            const arise = async () => {
                if (!apiKey) return;
                setPhase('emerging');
                const result = await ResonanceService.generate(apiKey, true, cycle, count);
                setManifest(result.content);
                setTimeout(() => setPhase('holding'), 5000);
            };

            useEffect(() => { if (isConfigured) arise(); }, [isConfigured]);

            if (!isConfigured) {
                return (
                    <div className="flex flex-col items-center justify-center h-screen bg-[#050505]">
                        <h2 className="text-xl tracking-widest mb-8">관찰의 준비</h2>
                        <input 
                            type="password" 
                            className="bg-transparent border-b border-white/20 p-2 text-center outline-none focus:border-white transition-colors"
                            placeholder="Gemini API Key"
                            onChange={(e) => setApiKey(e.target.value)}
                        />
                        <button 
                            className="mt-8 px-6 py-2 border border-white/20 hover:border-white transition-colors text-xs"
                            onClick={() => { localStorage.setItem('GEMINI_API_KEY', apiKey); setIsConfigured(true); }}
                        >
                            RESONATE
                        </button>
                    </div>
                );
            }

            return (
                <div className="w-full h-screen flex flex-col items-center justify-center relative overflow-hidden" onClick={arise}>
                    <div className="absolute inset-0 bg-[radial-gradient(circle_at_center,_#111_0%,_#000_90%)]" />
                    <main className="z-10 text-center">
                        <h1 className="text-2xl md:text-4xl tracking-[0.5em] transition-all duration-[5000ms]" style={{ opacity: phase === 'holding' ? 1 : 0 }}>
                            {manifest}
                        </h1>
                    </main>
                    <footer className="absolute bottom-8 text-[8px] tracking-widest opacity-30">Cultivated by Anonymous Farmer & Gemini</footer>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>